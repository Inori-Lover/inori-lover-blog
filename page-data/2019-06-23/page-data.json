{"componentChunkName":"component---src-templates-blog-post-js","path":"/2019-06-23/","result":{"data":{"site":{"siteMetadata":{"title":"乐园遗梦","author":"inori_lover"}},"markdownRemark":{"id":"e218c965-b9c4-5cc9-8b91-f56e969f7e05","excerpt":"session机制 原始的session 通过session，服务器与客户端得以在一段时间内同步状态，从而可以实现“流程”这个概念，以购物为例：通过session储存服务器可以知道客户端在添加了什么东西进购物车，知道发起结算的是哪位客户等等。一般情况下session…","html":"<h3>session机制</h3>\n<h4>原始的session</h4>\n<p>通过session，服务器与客户端得以在一段时间内同步状态，从而可以实现“流程”这个概念，以购物为例：通过session储存服务器可以知道客户端在添加了什么东西进购物车，知道发起结算的是哪位客户等等。一般情况下session都与cookie配合使用，服务器给每个不带cookie（或未登录等业务特征）的访客发放一个sessionID存在cookie中。客户端则在请求中附带上cookie，让服务器知道现在是谁在进行操作，业务上的流程限制也可以据此实现。</p>\n<h4>session重建</h4>\n<p>顾名思义，session储存的生命周期就是一个session（会话），当会话（浏览器窗口，标签页）关闭之后，客户端与服务器断开连接，服务器在适当延迟后则判断这个session储存属于“垃圾数据”，应该清除掉防止缓存被挤爆。这时候问题来了：每次重新打开客户端都要重新登录以建立session实在不利于网站的转化率，如何在不挤爆缓存的情况下让客户端可以保留session状态？答案是化整为零，每个用户在cookie中都各自储存用来重建session的必要数据，比如登录凭证。</p>\n<p>当服务器发现cookie中指示的sessionID已不存在时就校验cookie中的带有的登录凭证，如果登录凭证有效就按照数据库中存下来的session相关数据重建session（以购物流程举例，购物车，待付款订单等）。当然，为保安全这些敏感信息都应经过可靠加密后才下放客户端，在条件允许下利用hash等手段进行一次有损转换则可以进一步防止用户信息外泄。</p>\n<h4>session的缺点</h4>\n<p>在万维网初期session机制工作得非常好，但是随着万维网应用逻辑的逐渐复杂，session机制的限制也逐渐暴露出来：session作为一个集中式储存的概念，所有接口的都必须读写同一块地方以便同步状态；同时为了业务扩展，每次对数据处理时也会尽可能多地把数据往session中丢。</p>\n<p>在上边短短的描述当中就可以看到session的两大缺点：第一，session成为无可争议的超级热点，每个API都有极大可能对它进行频繁读写。第二，session很难进行管理，相比起数据库，session不提供事务机制，不提供可视化阅览，没法在代码中体现整体结构，逻辑繁复后甚至可能出现某两个API使用了冲突的session-key命名，导致难以调试的bug。</p>\n<p>其他还有灾难恢复困难，阻碍灰度部署以及不下线部署，无法在不同框架、语言间共享等。</p>\n<h3>token机制</h3>\n<h4>原始的token</h4>\n<p>个人理解里这个级别的token并不是为了取代session而出现，更多是作为一种补充手段，两者的表达力不能同一而论。在一些只需要认证等少数不变信息的接口中，session这种会造成io热点的储存手段显得过于笨重。作为替代，把少量的信息按照顺序进行编码甚至加密后下放客户端。在相关请求中只需附带上token，服务端根据token解码结果便可实现逻辑，不需要争抢session的io资源。</p>\n<h4>原始token的缺点</h4>\n<p>没有统一、有效的数据结构编码表达方式，难以在token中表达类似session的结构性数据，同时token验证资源成为新的热点。</p>\n<h4>jwt(json web token)</h4>\n<p>jwt是针对普通token的一次改进，以json为基础提供了一种语言通用的结构表达规范，弥补了纯token对复杂结构的表达力不足；同时提供了数种经过证明安全的加密、签名及其组合方案，适当选择使用后可对token携带的内容提供密码学级别的保障，实现token自签名，接口分布验证，无需查询中心数据源。\n在这个保障的基础上，出现了完全抛开session只使用jwt的可能性，这个手段有效避开了现代计算机中的io短板同时提供了足够的数据可信度，也更易于在多种语言、框架中进行状态共享。</p>\n<h4>jwt的缺点</h4>\n<p>拥抱jwt不依赖中心数据源的特性时，其可靠吊销手段只有自然过期及替换密钥，无法可靠提前注销指定部分token。</p>\n<h3>我的个人方案</h3>\n<p>假设每次jwt的验证都查询一次中心数据源，这样就等于退化为普通token验证了。</p>\n<p>秉承“能不做就不做，必须要做的就尽量延后做”的节能原则，我们不需要每次都校验jwt的有效，而是在token即将过期，需要重新签发时校验这个token是否能重新签发。在token仅因为过期而没有通过验证时，我们提取jwt中用户id并向中心数据源查询该用户是否符合重签策略，如符合，则覆写校验结果为真同时重新签发一个token。过期时间根据业务对有api封禁时差的容忍度（个人接触到的业务一般5分钟到15分钟的封禁误差都ok），确保token有效期减去重签倒计时小于指定的误差时间便可。</p>\n<h3>附</h3>\n<p>其实一开始的想法是分开两个token来签发，一个token是短效的（access token），他的生命周期就等于容忍误差；另一个是长效token（refresh token），生命周期取决业务需求，一周到一个月甚至季度都可以。每次请求下都发送两个token，当短效token因任何原因失效时，使用长效token作为重签校验。但在书写这篇blog时就有新的想法了，何苦使用两个token，只要在校验阶段拦截一下过期校验结果即可，虽然这在“机制”上就完全继承jwt而不是一个没有附加改动了（看起来稍稍low了一点）。</p>","frontmatter":{"title":"jwt漫谈","date":"October 06, 2019"}}},"pageContext":{"slug":"/2019-06-23/","previous":{"fields":{"slug":"/2019-02-23/"},"frontmatter":{"title":"怎么切割emoji😮"}},"next":{"fields":{"slug":"/2019-11-09/1/"},"frontmatter":{"title":"对env的理解"}}}},"staticQueryHashes":[]}