{"componentChunkName":"component---src-templates-blog-post-js","path":"/2021-01-23/1/","result":{"data":{"site":{"siteMetadata":{"title":"乐园遗梦","author":"inori_lover"}},"markdownRemark":{"id":"14ec74df-ceb2-5426-9818-036d44d0ae00","excerpt":"业务场景 我们经常都能遇到这样的产品要求：当页面 form 跟目前的状态没有改动时，不允许 form…","html":"<h2>业务场景</h2>\n<p>我们经常都能遇到这样的产品要求：当页面 form 跟目前的状态没有改动时，不允许 form 提交（或提交时做对应的交互拦截）；比如用户信息修改页面，只有用户的信息真的修改了，提交按钮才能点击，减少用户信息缓存重建流程。</p>\n<h2>一般思路</h2>\n<p>通过接口拉取页面所需信息并重建本地状态后，缓存下这个状态；之后每次本地状态修改后都触发一次深比较判断是否与原状态一致。</p>\n<h2>immer 的 patch</h2>\n<h3>来源</h3>\n<p>我们结合最简单的 immer 调用来解释这个信息的出处。</p>\n<div class=\"gatsby-highlight\" data-language=\"typescript\"><pre class=\"language-typescript\"><code class=\"language-typescript\"><span class=\"token keyword\">import</span> <span class=\"token punctuation\">{</span> produce <span class=\"token punctuation\">}</span> <span class=\"token keyword\">from</span> <span class=\"token string\">'immer'</span>\n\n<span class=\"token keyword\">const</span> base <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span> value<span class=\"token operator\">:</span> <span class=\"token number\">1</span> <span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">const</span> <span class=\"token function-variable function\">mutable</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>draft<span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n  base<span class=\"token punctuation\">.</span>value <span class=\"token operator\">+=</span> <span class=\"token number\">2</span>\n  base<span class=\"token punctuation\">.</span>value <span class=\"token operator\">-=</span> <span class=\"token number\">1</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">const</span> next <span class=\"token operator\">=</span> <span class=\"token function\">produce</span><span class=\"token punctuation\">(</span>base<span class=\"token punctuation\">,</span> mutable<span class=\"token punctuation\">)</span></code></pre></div>\n<p>immer 通过<code class=\"language-text\">Proxy</code>(或在降级环境使用<code class=\"language-text\">Object.defineProperty</code>)拦截掉对<code class=\"language-text\">draft</code>的每一个修改并记录下这次修改产生的 diff（immer 称之为 patch，以下用 patch 代指）；在执行完 mutable 后，immer 再根据 patch 信息在 base 的基础上进行新对象的建立。这完整走下来的流程也被称为<code class=\"language-text\">copy-on-write</code>(COW，写时复制)，是一种比较常见的优化策略。</p>\n<p>注意在举例代码中的 mutable 函数中，一共发生了两次修改操作，每次修改会产生一个 patch，整个 mutable 函数走完会产生两个 patch 信息（长度为 2 的 patch 信息数组）。</p>\n<h3>获取</h3>\n<p>我们对上边的示例代码做一点修改。</p>\n<div class=\"gatsby-highlight\" data-language=\"typescript\"><pre class=\"language-typescript\"><code class=\"language-typescript\"><span class=\"token comment\">// version 6</span>\n<span class=\"token keyword\">import</span> <span class=\"token punctuation\">{</span> produce<span class=\"token punctuation\">,</span> enablePatches <span class=\"token punctuation\">}</span> <span class=\"token keyword\">from</span> <span class=\"token string\">'immer'</span>\n<span class=\"token function\">enablePatches</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n\n<span class=\"token keyword\">const</span> recordPatches <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span>\n<span class=\"token keyword\">const</span> base <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span> value<span class=\"token operator\">:</span> <span class=\"token number\">1</span> <span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">const</span> <span class=\"token function-variable function\">mutable</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>draft<span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n  base<span class=\"token punctuation\">.</span>value <span class=\"token operator\">+=</span> <span class=\"token number\">2</span>\n  base<span class=\"token punctuation\">.</span>value <span class=\"token operator\">-=</span> <span class=\"token number\">1</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">const</span> next <span class=\"token operator\">=</span> <span class=\"token function\">produce</span><span class=\"token punctuation\">(</span>base<span class=\"token punctuation\">,</span> mutable<span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span>patches<span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> recordPatches<span class=\"token punctuation\">.</span><span class=\"token function\">push</span><span class=\"token punctuation\">(</span><span class=\"token operator\">...</span>patches<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">const</span> final <span class=\"token operator\">=</span> <span class=\"token function\">produce</span><span class=\"token punctuation\">(</span>next<span class=\"token punctuation\">,</span> mutable<span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span>patches<span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span>\n  recordPatches<span class=\"token punctuation\">.</span><span class=\"token function\">push</span><span class=\"token punctuation\">(</span><span class=\"token operator\">...</span>patches<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">)</span></code></pre></div>\n<blockquote>\n<p>从 immer@6 开始，patches 信息的输出需要先开启对应的 plugin 否则代码运行时会报错。</p>\n</blockquote>\n<p>这里我们注意到，produce 在第三参数位置接受一个回调，回调会传入本地修改产生的所有 patch 信息组成的数组作为参数，通过这种形式我们就可以记录所有修改产生的 patch 信息。</p>\n<h2>可是我需要的是修改比对，不是修改历史</h2>\n<p>上边介绍 patch 时我们强调过，patch 的获取时机是每一次 produce 运行后。假设你发生 2 次 produce 修改，那么即使你两次修改互相抵消了，最后的结果跟初始的结果深比较结果一致，patch 记录得到的信息也是两次 produce 操作产生的总和。所幸是在<a href=\"https://immerjs.github.io/immer/docs/patches\">官方文档</a>里作者推荐了一个<a href=\"https://medium.com/@dedels/using-immer-to-compress-immer-patches-f382835b6c69\">compress 解决方案</a>，虽然这个方案初衷应该是避免页面运行一段时间后 patch 记录数组消耗过大内存，但也刚好可以解决我们面临的问题：patch 不能真正反映修改差别情况。而且更妙的是，这个方案是通过 immer 自身的另一个特性来实现的，不需要加入冗长的业务逻辑，短短几行就能实现。</p>\n<h2>nice！但每次写这个功能都要把逻辑实现一次吗？</h2>\n<p>结合上一篇关于 useImmer 的博文，我们可以通过抽象一个 hook 的形式来简化使用成本，我们希望这个 hook 能实现常规的 useState（useImmer） 功能外，还能返回压缩后的 patches 而不用我们自己去计算；另外因为本地状态有可能是异步获取的，甚至定期获取，我们还希望有能力在业务逻辑中更新作为计算 patch 的基础状态，避免异步场景下无法使用的问题。同时，这个 patch 压缩最好还能尽可能少/晚执行，尽量减少运行时压力增量。</p>\n<p>这些功能全部都可以实现！（不如说我是先实现好了才举例的（跑</p>\n<h2>演示</h2>\n<p><a href=\"https://codesandbox.io/s/useimmeryanshi-ywvnf?fontsize=14&#x26;hidenavigation=1&#x26;theme=dark\"><img src=\"https://codesandbox.io/static/img/play-codesandbox.svg\" alt=\"codesandbox 演示\"></a></p>","frontmatter":{"title":"使用immer patch特性实现表单修改检测","date":"January 23, 2021"}}},"pageContext":{"slug":"/2021-01-23/1/","previous":{"fields":{"slug":"/2021-01-16/1/"},"frontmatter":{"title":"在react里边使用ES6 Set数据结构"}},"next":{"fields":{"slug":"/2021-02-10/1/"},"frontmatter":{"title":"如何存放菜单数据"}}}},"staticQueryHashes":[]}