{"componentChunkName":"component---src-templates-blog-post-js","path":"/2018-12-17/","result":{"data":{"site":{"siteMetadata":{"title":"乐园遗梦","author":"inori_lover"}},"markdownRemark":{"id":"00b36bf4-bc7e-5a97-912e-cad96f8d2968","excerpt":"tl;dr 没关系。 至少在简单项目里边没啥区别。 添加DLL的曲折 1. DLL的使用方式 之前因为一直都没接触DLL（仅仅是知道有DLL这个东西），整体处于“道理我都懂，爱上你自己上，反正我不上”的状态。这次 cra(create-react-app…","html":"<h1>tl;dr</h1>\n<p>没关系。</p>\n<p>至少在简单项目里边没啥区别。</p>\n<h1>添加DLL的曲折</h1>\n<h3>1. DLL的使用方式</h3>\n<p>之前因为一直都没接触DLL（仅仅是知道有DLL这个东西），整体处于“道理我都懂，爱上你自己上，反正我不上”的状态。这次 cra(create-react-app 简写，下同) 的编译实在太长时间了就想着当作补全盲点试着配置了，结果看文档看了半天才理解过来为啥要分开两个配置- -</p>\n<p>简单来说DLL就是把一部分依赖抽出来提前编译了一次，同时让编译结果可复用。那么提前编译怎么来？就是多写一个配置……多出来的配置写DLL生成，然后同时在原生的配置加一个引用指示，收工完事。</p>\n<p>不过这里又引出一个问题……为啥umi只需要一次编译操作就可以初始化DLL了？问得好。因为整个webpack脚本是动态生成的……也就是他其实是生成了两段脚本，只不过这个过程用户无感而已。简单来说就是在未公开的hook - _beforeDevServerAsync 添加一个build脚本的<a href=\"https://github.com/umijs/umi/blob/master/packages/umi-plugin-dll/src/index.js#L13\">Promise</a>, 这样在第一次启动（刷新）开发服务器前会检测一次DLL目录并把DLL的JSON解析出来依赖项的数组并与配置文件比对，没差就过，有差别就刷新DLL。</p>\n<h3>2. 为啥没用？</h3>\n<p>因为就是没用……</p>\n<p>当然如果要说代码层面的话，cra在ts状态下问题不在于dll之流的问题，babel的缓存也起了一定作用（个人理解冲掉了大部分DLL的功效，毕竟直接读缓存根本没走编译），而在于TS的语法检测插件上，去掉之后秒刷一点不假……</p>\n<h3>3. 遗憾</h3>\n<p>两个遗憾，一个是基本上是靠猜找出来的瓶颈，没有找到手段量化整个编译阶段。工具应该是有的（印象中看到过菊苣发文用过），但是没记起来名字。另一个则是没有debug到为什么DLL生成插件和引用插件需要传不同context，能追踪到是跟启动脚本有关但是没找到原因所在。cra简直黑科技集合体……</p>\n<h3>4. 关于umi</h3>\n<p>有点厉害但是个人来说不太想用……绑得太死了，连webpack都得拉分支出来了，作为集团选择应该很不错因为屏蔽了很多细节，不给太多犯错的机会，也给予足够的开发支持。但我不喜欢的也在这个地方，封装好深好深，屏蔽了太多细节，有种双脚离地的感觉。特别是脱离webpack的做法很让我担心：万一各种缘由下不得不停止项目支持，那么迁移到原生webpack的难度如何？cra好歹能eject把实现丢出来，有个万一都能改得动。</p>\n<p>晚安（早安？）\n2018年12月17日05点26分</p>","frontmatter":{"title":"create-react-app@2 withTS 编译速度跟dll的关系","date":"December 16, 2018"}}},"pageContext":{"isCreatedByStatefulCreatePages":false,"slug":"/2018-12-17/","previous":{"fields":{"slug":"/2018-12-10/"},"frontmatter":{"title":"工作小结"}},"next":{"fields":{"slug":"/2018-12-17-2/"},"frontmatter":{"title":"一些想补的基础：new机制，原型"}}}}}