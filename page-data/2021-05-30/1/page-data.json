{"componentChunkName":"component---src-templates-blog-post-js","path":"/2021-05-30/1/","result":{"data":{"site":{"siteMetadata":{"title":"乐园遗梦","author":"inori_lover"}},"markdownRemark":{"id":"b63d971e-1ec7-5c31-b50b-d35e9d5f9e64","excerpt":"动机 最近在准备面试的时候想重温一下JS的基础，也包括自己以前写下过的文字，原型链问题就成了一个不可忽视的题目了。然而在读自己之前写下来的(文章)/2018-12-17-…","html":"<h1>动机</h1>\n<p>最近在准备面试的时候想重温一下JS的基础，也包括自己以前写下过的文字，原型链问题就成了一个不可忽视的题目了。然而在读自己之前写下来的(文章)[/2018-12-17-2/]时发现各个地方逻辑都不太流畅，故产生了重新写一篇的念头。</p>\n<h1><code class=\"language-text\">constructor</code>, <code class=\"language-text\">prototype</code>, <code class=\"language-text\">__proto__</code></h1>\n<p>要理解好原型先要理清这几个东西，绝大部分的原型问题都是围绕着这三个问题存在或者延申。</p>\n<h2><code class=\"language-text\">constructor</code></h2>\n<p>简单理解就是一个普通的<code class=\"language-text\">key</code>而已，没有特别的作用。它不参与原型回溯，只是作为一个记录存在：只要你<code class=\"language-text\">new</code>我的<code class=\"language-text\">constructor</code>，那么你就能得到跟我一样的原型。</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">function</span> <span class=\"token constant\">A</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>name <span class=\"token operator\">=</span> <span class=\"token string\">'A'</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token class-name\">A</span><span class=\"token punctuation\">.</span>prototype<span class=\"token punctuation\">.</span><span class=\"token function-variable function\">test</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">function</span> <span class=\"token function\">test1</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">const</span> a <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">A</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">const</span> b <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">a<span class=\"token punctuation\">.</span>constructor</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n\na<span class=\"token punctuation\">.</span>constructor <span class=\"token operator\">===</span> <span class=\"token constant\">A</span> <span class=\"token comment\">// true</span>\na<span class=\"token punctuation\">.</span>constructor <span class=\"token operator\">===</span> b<span class=\"token punctuation\">.</span>constructor <span class=\"token comment\">// true</span>\na<span class=\"token punctuation\">.</span>__proto__ <span class=\"token operator\">===</span> b<span class=\"token punctuation\">.</span>__proto__ <span class=\"token comment\">// true</span>\na<span class=\"token punctuation\">.</span>test <span class=\"token operator\">===</span> b<span class=\"token punctuation\">.</span>test <span class=\"token comment\">// true</span></code></pre></div>\n<h2><code class=\"language-text\">prototype</code></h2>\n<p>从这里开始出现js特有的概念了：<code class=\"language-text\">prototype</code>并不是所有对象都有的<code class=\"language-text\">key</code>，大部分对象取这个<code class=\"language-text\">key</code>只能得到<code class=\"language-text\">undefined</code>。这跟它的起源、用意有关：它只出现在能作为<code class=\"language-text\">constructor</code>的对象上，作为实例的“原型(<code class=\"language-text\">__proto__</code>)”存在。目前我所了解在js能作为<code class=\"language-text\">constructor</code>的对象就只有函数了(就算是各种原生对象，比如<code class=\"language-text\">String</code>、<code class=\"language-text\">Array</code>本质上也只是函数，可<code class=\"language-text\">typeof</code>验证一下)。又因为JS在设定上，任何函数都可以被用作<code class=\"language-text\">constructor</code>来产生实例，所以这里可以这样简化理解：任何函数都会带有<code class=\"language-text\">prototype</code>属性，作为它的实例的“原型”对象，所有实例都共享（引用）这个对象。</p>\n<blockquote>\n<p>注意这里”函数都能用做<code class=\"language-text\">constructor</code>”、”<code class=\"language-text\">prototype</code>只存在于<code class=\"language-text\">constructor</code>“属于方便理解的说法，JS规范并没有如此说法，实际JS环境也存在反例：<code class=\"language-text\">Symbol</code>是一个函数也拥有<code class=\"language-text\">prototype</code>，但<code class=\"language-text\">new Symbol()</code>会抛错告诉你<code class=\"language-text\">Symbol</code>不是一个<code class=\"language-text\">constructor</code>；包括下边示例的箭头函数。</p>\n</blockquote>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">function</span> <span class=\"token constant\">A</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span>\n<span class=\"token class-name\">A</span><span class=\"token punctuation\">.</span>prototype <span class=\"token comment\">// {constructor: A}</span>\n<span class=\"token keyword\">const</span> <span class=\"token function-variable function\">A1</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">function</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span>\n<span class=\"token class-name\">A1</span><span class=\"token punctuation\">.</span>prototype <span class=\"token comment\">// {constructor: A1}</span>\n<span class=\"token keyword\">const</span> <span class=\"token function-variable function\">A2</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span>\n<span class=\"token class-name\">A2</span><span class=\"token punctuation\">.</span>prototype <span class=\"token comment\">// undefined</span>\n<span class=\"token keyword\">new</span> <span class=\"token class-name\">A2</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token comment\">// Uncaught TypeError: A2 is not a constructor</span>\n\n<span class=\"token keyword\">var</span> <span class=\"token constant\">B</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span>\n<span class=\"token class-name\">B</span><span class=\"token punctuation\">.</span>prototype <span class=\"token comment\">// undefined</span></code></pre></div>\n<p>通过在<code class=\"language-text\">new</code>操作时，将构造器的<code class=\"language-text\">prototype</code>赋值给实例的<code class=\"language-text\">__proto__</code>键，使所有实例都通过<code class=\"language-text\">__proto__</code>键共享到同一个对象。</p>\n<p>每个构造器的<code class=\"language-text\">prototype</code>都是在定义好就存在的，初始状态它的值就只包含一个<code class=\"language-text\">key</code>：<code class=\"language-text\">constructor</code>，value就是构造器本身。</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">function</span> <span class=\"token constant\">A</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span>\n<span class=\"token class-name\">A</span><span class=\"token punctuation\">.</span>prototype <span class=\"token comment\">// {constructor: A}</span>\n<span class=\"token class-name\">A</span><span class=\"token punctuation\">.</span>prototype<span class=\"token punctuation\">.</span>constructor <span class=\"token operator\">===</span> <span class=\"token constant\">A</span> <span class=\"token comment\">// true</span></code></pre></div>\n<h2><code class=\"language-text\">__proto__</code></h2>\n<p><code class=\"language-text\">__proto__</code>是一个特殊的键值，是直接用于原型回溯的键值：定义在<code class=\"language-text\">__proto__</code>的值、函数能被对象本身直接引用。它来源于<code class=\"language-text\">new</code>操作时传入的<code class=\"language-text\">constructor</code>的<code class=\"language-text\">prototype</code>。</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">const</span> <span class=\"token constant\">A</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span>\n<span class=\"token constant\">A</span><span class=\"token punctuation\">.</span>__proto__<span class=\"token punctuation\">.</span>test <span class=\"token operator\">=</span> <span class=\"token number\">1</span>\n<span class=\"token constant\">A</span><span class=\"token punctuation\">.</span>test <span class=\"token comment\">// 1</span></code></pre></div>\n<p>结合<code class=\"language-text\">prototype</code>小节的描述，我们可以一窥原型继承的秘密了：<code class=\"language-text\">new</code>操作得到的实例，都通过<code class=\"language-text\">__proto__</code>共享同一个对象；而实例又能直接引用<code class=\"language-text\">__proto__</code>里的键值，在调用上看起来就像实例都“拥有”了原型的方法了。</p>\n<h1>Object.getPrototypeOf()</h1>\n<p>这个操作实际上跟操作<code class=\"language-text\">__proto__</code>没什么区别了，只是在边界情况、fallback上会有(更多的处理)[https://github.com/es-shims/Reflect.getPrototypeOf/blob/main/implementation.js]。</p>\n<h1>扩展阅读：class</h1>\n<p>作为ES6引入的语法糖，<code class=\"language-text\">class</code>的写法比起原型链写法更容易理解，同时限制了动态修改原型的做法，使得代码更容易被静态分析了。另外，通过窥探poyfill的实现，也有助于我们加深对JS原型继承的理解。</p>\n<blockquote>\n<p>(ts playground)[https://www.typescriptlang.org/play?target=1&#x26;module=0&#x26;ssl=13&#x26;ssc=6&#x26;pln=11&#x26;pc=4#code/MYGwhgzhAECC0G8BQ1XWAewHYQC4CcBXYXDfaACgAd8BLANzFwFNoswBbVgXmgHJYfAJSIUaAL5IxqKoQBGIWsGiyFSgHKce-WADpVi4Jq58paFfMPQA5s1zHWFEcnPn8dwvizRcAC1oQuuxcANzS0JLhBko2dg4AQrRYACbQvE5pAHyirmjuuJ7efgFBWmHmkpGgkDDx0MwAHiwpMPAuaJg4BMSk5BTB2gLCObnQEIRUzPj9WkLhkeY0DEys8Q5p-PGmi5YxtrhrWpTO4W4eXj7+gYdc81G7yvs3zIkpGxnc2e25+YWXJc87uIgA]</p>\n</blockquote>\n<blockquote>\n<p>(babel repl)[https://babeljs.io/repl#?browsers=&#x26;build=&#x26;builtIns=false&#x26;corejs=3.6&#x26;spec=false&#x26;loose=false&#x26;code_lz=MYGwhgzhAECC0G8BQ1XWAewHYQC4CcBXYXDfaACizAFsBTaAXmgHJYWBKRFNVXACwCWEAHTV6TaOLo9UAXySzoAB0IAjEIOAA5Wg2ZsRqjVt30Wi3gHM6uMwwpdkvXvluF8WaAOFi9AbiUFJRs7PQAhQSwAE0lHJgA-bhc0N1wPLx9RaUDeBWDQSBhw6DoAD1w6GJh4ZzRMHAJiUnIqPUk2TmSU6AhCZTp8NvoOIMs0cPsO8ItrW0n2-LqUtIzvIVEF-jG53C26SJi4rkYk5ZdVz3XffbG5IA&#x26;debug=false&#x26;forceAllTransforms=false&#x26;shippedProposals=false&#x26;circleciRepo=&#x26;evaluate=false&#x26;fileSize=false&#x26;timeTravel=false&#x26;sourceType=script&#x26;lineWrap=false&#x26;presets=env%2Ces2015%2Ces2016%2Ces2017&#x26;prettier=false&#x26;targets=&#x26;version=7.9.0&#x26;externalPlugins=%40babel%2Fplugin-proposal-class-properties%407.13.0]</p>\n</blockquote>\n<p>通过两个框架的实现我们可以了解到许多有意思的地方：比如<code class=\"language-text\">prototype</code>的来源，在ts的实现里这个行为比较容易找到，也印证了上边提到的一个说法：初始状态<code class=\"language-text\">constructor</code>的<code class=\"language-text\">prototype</code>就只带有一个<code class=\"language-text\">key</code>: <code class=\"language-text\">constructor</code>，它指向的就是<code class=\"language-text\">constructor</code>自身；比如<code class=\"language-text\">prototype</code>的使用，<code class=\"language-text\">class</code>的方法定义也是通过对<code class=\"language-text\">prototype</code>赋值来实现的，印证了语法糖一说。</p>\n<blockquote>\n<p>两个框架的实现都不约而同遵循了一个小小原则：<code class=\"language-text\">property</code>都定义在<code class=\"language-text\">this</code>上（即使这个<code class=\"language-text\">property</code>实际上指向一个<code class=\"language-text\">function</code>），而<code class=\"language-text\">function</code>则定义在<code class=\"language-text\">prototype</code>上了。可能规范对此有所限制？</p>\n</blockquote>\n<h1>经典试题</h1>\n<h2>手动实现new操作</h2>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">function</span> <span class=\"token function\">customNew</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">constructor<span class=\"token punctuation\">,</span> <span class=\"token operator\">...</span>args</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">const</span> result <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span>\n  <span class=\"token function\">constructor</span><span class=\"token punctuation\">.</span><span class=\"token function\">bind</span><span class=\"token punctuation\">(</span>result<span class=\"token punctuation\">)</span><span class=\"token punctuation\">(</span><span class=\"token operator\">...</span>args<span class=\"token punctuation\">)</span>\n  <span class=\"token comment\">// 网传大部分代码这里还需要写一行`constructor`赋值语句，但我觉得不必要；</span>\n  <span class=\"token comment\">// 通过观察`prototype`可知，`constructor`是初始就存在的，指向的也正是`constructor`本身</span>\n  <span class=\"token comment\">// 写出来估计是为了标明知识点？</span>\n  result<span class=\"token punctuation\">.</span>__proto__ <span class=\"token operator\">=</span> constructor<span class=\"token punctuation\">.</span>prototype\n\n  <span class=\"token keyword\">return</span> result\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">function</span> <span class=\"token function\">Shape</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>name <span class=\"token operator\">=</span> <span class=\"token string\">'Shape'</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token class-name\">Shape</span><span class=\"token punctuation\">.</span>prototype<span class=\"token punctuation\">.</span><span class=\"token function-variable function\">test</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">function</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">const</span> a <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Shape</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">const</span> b <span class=\"token operator\">=</span> <span class=\"token function\">customNew</span><span class=\"token punctuation\">(</span>Shape<span class=\"token punctuation\">)</span>\n\na<span class=\"token punctuation\">.</span>name <span class=\"token operator\">===</span> b<span class=\"token punctuation\">.</span>name <span class=\"token comment\">// true</span>\na<span class=\"token punctuation\">.</span>test <span class=\"token operator\">===</span> b<span class=\"token punctuation\">.</span>test <span class=\"token comment\">// true</span>\na<span class=\"token punctuation\">.</span>constructor <span class=\"token operator\">===</span> b<span class=\"token punctuation\">.</span>constructor <span class=\"token comment\">// true</span>\na<span class=\"token punctuation\">.</span>__proto__ <span class=\"token operator\">===</span> b<span class=\"token punctuation\">.</span>__proto__ <span class=\"token comment\">// true</span></code></pre></div>\n<h1>what is next</h1>\n<p>下次继续要对原型做更深入理解的话需要啃ES规范原文了，届时应该可以对<code class=\"language-text\">new</code>操作有更深一层的了解，比如为何箭头函数、<code class=\"language-text\">Symbol</code>不能被<code class=\"language-text\">new</code>，通过什么手段实现的（黑名单还是隐藏的slot），是否还有同类，等。</p>","frontmatter":{"title":"重温原型","date":"May 30, 2021"}}},"pageContext":{"slug":"/2021-05-30/1/","previous":{"fields":{"slug":"/2021-05-08/1/"},"frontmatter":{"title":"如何是实现范围随机数取值"}},"next":null}},"staticQueryHashes":[]}