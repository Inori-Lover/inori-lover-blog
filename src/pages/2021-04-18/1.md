---
title: Promise成本及有限并发

# []: (new Date()).toJSON()
date: '2021-04-18T13:40:25.529Z'
---

## 缘由

最近在关注面试相关的东西，知乎上偶然就遇到这么一则帖子：[JavaScript 面试题一则：有限并行](https://zhuanlan.zhihu.com/p/360193435)。简单概括，面试官出题询问`await Promise.all(urls.map(url => fetch(url)))`与`const results = [];for (const url of urls ) {results.push(await fetch(urls[i]))}`两者的区别与优劣，包括是否有优化的地方。借由串行不够高效、全并发瞬时创建大量的 Promise 和函数上下文影响性能为由，引出了有限并发的意义及实现。这个面试题也让我联想到了曾经使用[Taro](https://github.com/NervJS/taro)时框架开箱提供对`wx.request`的[并发控制](https://developers.weixin.qq.com/miniprogram/dev/framework/ability/network.html#使用限制)。

## 一点点吐槽：大量创建 Promise 消耗有多大？

以下是在空白页面的 console 中运行以下三句代码并利用 Performance 面板来记录的运行 cpu 及内存消耗的方法进行比对，表格中括号值为与第一行（创建大数组操作）的比值。

```js
urls = new Array(10 ** 6).fill('')
random = urls.map(() => `${Math.random()}`)
promise = await random.map((s) => new Promise((r) => r(`1${s}`)))
```

| 行号 | 运行时间(ms)    | 运行前    | 运行后    | 增值              |
| ---- | --------------- | --------- | --------- | ----------------- |
| 1    | 364.81          | 90863712  | 114394488 | 23530776          |
| 2    | 509.05(139.54%) | 114394488 | 175121296 | 60726808(258.07%) |
| 3    | 425.70(116.69%) | 175121296 | 243238820 | 68117524(289.48%) |

通过这个表格我们可以注意到，比起创建一个同等长度的随机数字符串数组，创建同等长度的 Promise 对象数组更快，内存占用虽稍高但也仅仅高出 12.17%；同时比起创建大量对象，创建一个大数组本身的消耗更加可观。我们无需觉得 Promise.all 是毒药或者猛兽，大批量的异步操作任务创建并不会成为性能热点，更需要关注的是数据以及异步操作本身。

> 是否可以这么想：与其探究并发控制，不如研究为何出现大并发本身？毕竟就算控制了并发量，你也无法避开创建大数组来存放 fetch 结果，加上一般数据的使用前还得进行数据处理等，这个创建可能要出现数次。

> 以上说法并不能代表你在实际项目中就可以数十数百地并行 fetch。一来浏览器本身就有并发控制，我们对同一个域名的请求一般只有 6 到 8 个（具体看浏览器实现）；二来创建 http 请求本身消耗并不像创建 Promise 这样低（websocket 是否会好点？）。

## 如何设计有限并发

词语拆分，有限 与 并发。前者限制数量，可以方便表示容量的数据结构都可以，常见的有数组，Set，Map 等；并发，这个就绕不开 Promise 了，可能还有在此之上的 generator 和 async func 等。用数组限制数量，用 Promise 控制并发，每个 Promise resolve 之后检查有没有下一个任务；这就是有限并发的核心逻辑。接下来是 API 设计。

有限并发一般应用场景有两种，一种是静态，如上边面试题提到的，已知全部任务，并发执行；另一个是动态，我不知道什么时候会有下一个，我只管并发最多只能是我指定的，如上边提到的 taro 对 request 的并发限制。前者单进单出，一次拿到数据即可（需要 asap 拿到的话可以通过 hooks 等单独透出），后者相对复杂，场景可能要求得到单个操作的 Promise 结果，也可能需要知道全部的结果；可能需要移出队列的能力，也可能需要竞态状况（已消费长度、待消费长度等）。在功能涵盖这个事情上，后者涵盖了前者所有的功能，那么我们不妨简化一下场景，设计时有限考虑后者动态指定的场景，再回头看对静态指定场景带入的压力是否合理，适当均衡两头压力甚至对动态场景做一层封装便可。

### 动态指定

实现动态指定最简单的方法肯定是新建一个资源 pool，需要添加的时候就调用一下 add 函数压入一个 Promise 并返回一个新的 Promise 指示该任务执行状态。

```ts
class Pool {
  /** 待处理 */
  private pendding: (() => Promise<unknown>)[] = []
  /** 资源池 */
  private pool: (() => Promise<unknown>)[] = []

  constructor(/** 资源池深度 */ private depth: number = 1) {
    //
  }

  /** 补全全部资源池空位（可能情况下） */
  private run = (): void => {
    //
  }

  /** 压入任务 */
  public add = <T = unknown>(task: () => Promise<T>): Promise<T> => {
    return {} as any
  }

  /** 获取当前等待队列长度 */
  public get pendingLen() {
    return this.pendding.length
  }

  /** 获取当前设置的资源池深度 */
  public get bufferLen() {
    return this.depth
  }

  /** 获取当前设置的资源池深度，实时，可能与设置值不一致（动态扩容、缩容的情况） */
  public get poolDepth() {
    return this.pool.length
  }

  /** 修改资源池深度 @param bufferLen 深度，必须大于等于1否则抛错 */
  public changeBuffenLen = (bufferLen: number) => {
    this.depth = bufferLen
  }
}
```

## 更新预告

《如何维护列表数据》
