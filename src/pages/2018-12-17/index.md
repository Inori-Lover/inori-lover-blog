---
title: create-react-app@2 withTS 编译速度跟dll的关系

[]: # (new Date()).toJSON()
date: "2018-12-16T21:01:22.594Z"
---

# tl;dr
没关系。

至少在简单项目里边没啥区别。

# 添加DLL的曲折

### 1. DLL的使用方式
之前因为一直都没接触DLL（仅仅是知道有DLL这个东西），整体处于“道理我都懂，爱上你自己上，反正我不上”的状态。这次 cra(create-react-app 简写，下同) 的编译实在太长时间了就想着当作补全盲点试着配置了，结果看文档看了半天才理解过来为啥要分开两个配置- -

简单来说DLL就是把一部分依赖抽出来提前编译了一次，同时让编译结果可复用。那么提前编译怎么来？就是多写一个配置……多出来的配置写DLL生成，然后同时在原生的配置加一个引用指示，收工完事。

不过这里又引出一个问题……为啥umi只需要一次编译操作就可以初始化DLL了？问得好。因为整个webpack脚本是动态生成的……也就是他其实是生成了两段脚本，只不过这个过程用户无感而已。简单来说就是在未公开的hook - _beforeDevServerAsync 添加一个build脚本的[Promise](https://github.com/umijs/umi/blob/master/packages/umi-plugin-dll/src/index.js#L13), 这样在第一次启动（刷新）开发服务器前会检测一次DLL目录并把DLL的JSON解析出来依赖项的数组并与配置文件比对，没差就过，有差别就刷新DLL。

### 2. 为啥没用？
因为就是没用……

当然如果要说代码层面的话，cra在ts状态下问题不在于dll之流的问题，babel的缓存也起了一定作用（个人理解冲掉了大部分DLL的功效，毕竟直接读缓存根本没走编译），而在于TS的语法检测插件上，去掉之后秒刷一点不假……

### 3. 遗憾
两个遗憾，一个是基本上是靠猜找出来的瓶颈，没有找到手段量化整个编译阶段。工具应该是有的（印象中看到过菊苣发文用过），但是没记起来名字。另一个则是没有debug到为什么DLL生成插件和引用插件需要传不同context，能追踪到是跟启动脚本有关但是没找到原因所在。cra简直黑科技集合体……

### 4. 关于umi
有点厉害但是个人来说不太想用……绑得太死了，连webpack都得拉分支出来了，作为集团选择应该很不错因为屏蔽了很多细节，不给太多犯错的机会，也给予足够的开发支持。但我不喜欢的也在这个地方，封装好深好深，屏蔽了太多细节，有种双脚离地的感觉。特别是脱离webpack的做法很让我担心：万一各种缘由下不得不停止项目支持，那么迁移到原生webpack的难度如何？cra好歹能eject把实现丢出来，有个万一都能改得动。

晚安（早安？）
2018年12月17日05点26分
